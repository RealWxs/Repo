# 广度优先搜索

对于无权图，广度优先搜索总是先搜索完毕所有距离源节点距离为k的所有节点才会搜索距离为k+1的节点，正因如此，广度优先搜索得到的是最短路径

算法伪代码

```pseudocode
BFS(G,s)
for each vertex u 属于 G.V - s
	u.color = WHITE
	u.d = inf
	u.predecessor = nil
s.color = GREY
s.d = 0
s.predecessor = nil
Q = 空集
q.enqueue(s)
while Q is not 空集
	u = Q.dequeue()
	for each v，v与u相邻
		if v.color == WHITE
			v.color = GREY
			v.d = u.d + 1
			v.predecessor = u
			Q.enqueue(v)
	u.color = BLACK
```

算法使用三种颜色表示一个节点的不同阶段，白色代表未被发现过，灰色代表已经被发现，黑色代表已经被处理

算法将源节点加入FIFO队列，在队列非空时，取出一个节点，将其所有相邻的白色节点的距离上界d设为该节点的距离上界+1，然后将这些白色节点变为灰色，依次放入队列。（队列中的点都是被发现过的，因此都是灰色的）在处理完这个节点的所有相邻节点后，将这个节点变为黑色。（黑色节点的所有相邻节点肯定是灰色或黑色）

### 时间复杂度分析

1. 在初始化操作时，每个节点变为白色，初始化完成后不会有新的白色节点，初始化的时间复杂度为$\Theta(V)$

2. 在检查某个出队节点的相邻节点时，所有的白色节点变为灰色并入队。因为不会再产生新的白色节点，而所有节点初始都为白色，因此每个节点恰好入队和出队一次

3. 在队列为空时说明所有节点都变为了黑色，也就是都恰好经历了一次入队和出队。while循环共执行了O(V)次

4. 在每个节点出队时，对其临接链表进行扫描，因为每个节点恰好出队一次，所以扫描总共为$\Theta$(E)次

5. 综上，总的时间复杂度为$\Theta(V+E)$ 

   

### BFS正确性的证明

- 最短路径距离$\delta$(s,v) :从结点s到结点v之间所有路径里面最少的边数（最短距离）

### 引理（三角不等式）：设s为图G任一顶点，则对于任意边(u, v) ，都有$\delta(s,v)\le\delta(s,u)+1$

**证明：**在u对于原点可达到情况下，v也对于原点可达，原点到v的最短距离不可能比原点到u的最短距离+1更长，因为$\delta(s,u)+1$已经是已知最短路径的一个上界，长度大于这个值的路径不能够作为最短路径。在u不可达时, $\delta(s,u) = \infty$，不等式显然成立。

### 引理（上界性质）：在BFS运行结束时，对于所有节点都有$v.d \ge\delta(s,v)$

**证明：**使用归纳法进行证明。基本情况为源节点s加入队列Q时，$s.d = 0 = \delta(s,s)$,对于所有的节点，$v.d = \infty \ge \delta(s,v) = \infty$。对于任一节点u，对于从u的邻接链表中发现的白色节点v，根据归纳假设有$v.d \ge\delta(s,v)$。对于白色节点的赋值操作，有$v.d = u.d + 1 \ge \delta(s,u)+1 \ge \delta(s,v)$。因为白色节点在设置了d值之后变为灰色，而d值的修改只对于白色节点，因此任何一个节点的d在修改一次后就不再发生变化，在后续的流程中不等式会一直保持。

### 引理（队列Q中至多有两种不同的d值，即最多保存两层深度的节点）：BFS在图G上运行的过程中，队列Q中包含的节点为<v1,v2, . . . ,vr>，那么有$v_r.d\le v_1.d+1$,并且对于i = 1,2, . . . ,r-1，都有$v_i.d \le v_{i+1}.d$

**证明：**使用归纳法证明。初始情况下，Q中只包含源节点s，引理成立。

​			对于归纳步，在v1出队后，v2成为新的头节点，根据归纳假设有$v_1.d \le v_2.d$,又因为$v_r.d\le v1.d+1$，所以有$v_r.d\le v_2.d+1$,其他不等式不受影响，因此在v2为头节点时引理成立。在删除了节点v1后，在队列中加入与v1相邻的白色节点$v_{r+1}$，根据对白色节点d值的处理可得,$v_{r+1}.d = v_1.d + 1$。又因为$v_r.d\le v_1.d+1$，所有有$v_r.d \le v_{r+1}.d$。因为$v_1.d\le v_2.d$，所以$v_{r+1}.d = v_1.d+1\le v_2.d+1$。其他不等式不受影响，归纳假设成立。

### 推论（在节点加入队列时，节点的d值随加入时间单调非减）：假定在执行BFS时，节点vi和vj都加入到队列Q里，并且vi在vj前面入队，则有$v_i.d\le v_j.d$

**证明：**因为队列中最多存在两个不同的d值且前面的d值不大于后面的，而且每个节点d值被修改后就不在变化，所以推论成立。

### 定理（BFS的正确性证明）：在BFS算法终止时，对于所有的节点v，都有$v.d = \delta(s,v)$，而且对于任意从s可达的节点v($v \not= s$)，从s到v到一条最短路径为s到v前驱u的最短路径加上边(u,v)

证明：使用反证法证明。假设某些节点的d值不等于最短路径距离。设v是这样的节点，其最短路径长度为      $\delta(s,v)$，且和v.d不相等。根据上界性质与假设，有$v.d \gt \delta(s,v)$。此外，v一定是从原点可达的，否则$\delta(s,v) =  \infty$,与题设矛盾。设u为s到v最短路径上v的直接前驱，则有$\delta(s,v) = \delta(s,u)+1$。因为$\delta(s,u) \lt \delta(s,v)$，而且$\delta(s,u) = u.d$。所以有$u.d +1 = \delta(s,u) +1 = \delta(s,v)\lt v.d$。在u出队，对u的邻接点进行考察时，如果v是白色的，那么有v.d = u.d+1，与不等式矛盾；如果v是灰色的，设v是通过节点k发现的，而节点k入队时间早于u，根据推论有$k.d\le u.d$，所以有$v.d = k.d+1\le u.d+q1$，与不等式矛盾；如果v是黑色的，那么v早于u出队，根据推论得$v.d \le u.d$，与不等式矛盾。综上，对于所有的v，都有$v.d = \delta(s,v)$，因为v的前驱节点为u，根据d值的修改步骤，有v.d = u.d+1。QED


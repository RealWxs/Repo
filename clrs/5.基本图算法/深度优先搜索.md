# 深度优先搜索

- 每次在发现的节点中取出最近加入的进行搜索
- 对每个节点u维护发现时间u.d与完成时间u.f两个信息，显然，u.d<u.f

伪代码：

```pseudocode
DFS(G)
for each vertex u 属于 G.V
	u.color = WHITE
	u.前驱 = NIL
time = 0
for each vertex u 属于 G.V
	if u.color == WHITE
		DFS-VISIT(G,u)
		

DFS-VISIT(G,u)
time = time + 1
u.d = time
u.color = GREY
for each v,v是u的邻边
	if v.color == WHITE
		v.前驱 = u
		DFS-VISIT(G,u)
u.color = BLACK
time = time + 1
u.f = time
```

### 时间复杂度分析

1. dfs中对每个顶点初始化与for循环考察每个节点的时间复杂度为$\Theta(E)$
2. 对于dfs中的第二个for循环调用visit函数与visit中的递归调用，由dfs的原理可知，由于只对白色的节点进行dfs搜索且每个白色节点一旦被发现就会变味灰色且不会逆转，因此总共对每个节点恰好调用了一次visit函数，时间复杂度为$\Theta(V)$
3. 综上，总共的时间复杂度为$\Theta(V+E)$

### 括号化定理：在对图G进行的任意DFS中，对于任意两个节点u与v，下面三种情况有且仅有一个成立

- 区间[u.d, u.f]和区间[v.d, v.f]完全分离，在深度优先森林中，u不是v的后代，也不是v的前驱，反之亦然。
- 区间[u.d, u.f]完全包含在区间[v.d, v.f]中，在深度优先树中，u是v的后代
- 区间[v.d, v.f]完全包含在区间[u.d, u.f]中，在深度优先树中，v是u的后代

证明：不妨设u.d<v.d，在此前提下分为两种情况。第一，v.d<u.f，说明在u为灰色即在u处理完之前发现了v，此时v是u的后代；第二，v.d>u.f，则根据d与f的关系可得u.d<u.f<v.d<v.f，因为u.f<v.d，说明u在处理完之后才发现了v，即v不是u的后代。这就证明了第一种和第三种情况，第二种情况与第三种是对称的，显然成立。

### 推论（后代区间的嵌套）：在DFS产生的深度优先森林中，v是u的后代当且仅当u.d<v.d<v.f<u.f



### 白色路径定理：在图G的深度优先森林中，v是u的后代当且仅当在发现u的时间u.d，存在一条从节点u到节点v的全部由白色节点构成的路径。

证明：

充分性：如果v = u，u到v的路径中只存在u，而在发现u的时候u为白色，题设成立。如果v是u的真后代，根据括号化定理的推论有u.d<v.d<v.f<u.f，也就是说在发现u的时候还没有发现v，因此此时v为白色。因为v可以是u的任意后代，所以在深度优先森林中从u到v到唯一简单路径上的所有节点在时刻u.d都是白色的。

必要性：假设在时刻u.d存在一条u到v的白色路径，而v在深度优先树中不是u的后代。设v的所有前驱都是u的后代，否则可以令v是第一个不是u后代的节点。设w为路径上v的前驱，根据括号化定理的推论，有$w.f\le u.f$，因为v是w的后代，所以有$w.d<v.d<v.f<w.f$，可得[v.d, v.f]完全包含在[u.d, u.f]中，即v是u的后代，与假设矛盾。综上，题设得证。

### 输入图G中边的分类

1. 树边：树边是深度优先树的边，是在某时刻由灰色节点发现白色节点而加入的边。

2. 后向边：后向边是将一个节点u连接到其祖先节点v的边，自循环也被认为是后向边。

3. 前向边：将节点u连接到其在深度优先树中的一个后代v的边。

4. 横向边：连接不同深度优先树中两个节点，或连接同一棵深度优先树中无后代关系的两个节点的边。

   ### 通过节点颜色判定边的种类：

   设节点u为灰色，在第一次探索到边(u,v)时

   1. 若v是白色的，则为树边
   2. 若v是灰色的，则为后向边
   3. 若v是黑色的，则为横向边或前向边

   证明：

   1. 由DFS工作原理立即得
   2. 若v为灰色的，说明v在通过u发现之前就被发现过且目前处于活跃状态，因此有v.d<u.d，显然v不是u的子节点（因为v在通过u发现时为灰色，无法将u作为v的前驱），所以u.f<v.f，因为u完成时所有子节点都已经完成，由括号化定理得u是v的子节点。
   3. 若v是黑色的，则有v.f<u.f。对此可分为两种情况，第一，v.f<u.d，说明在u发现前v就已经处理完成了，因此u不是v的子节点，而且v显然不是u的子节点，此时(u,v)是横向边；第二，u.f<v.d，由括号化定理得v是u的后代，此时(u,v)是前向边。

### 定理（DFS运行中首次考察到边的分类）：在对无向图G进行深度优先搜索是，每条边在第一次被发现时要么是树边，要么是后向边。

证明：设(u,v)是G的任意一条边，不妨设u.d<v.d。因为v与u相邻，在u处理完成之前一定会发现和完成对v的处理。如果DFS在第一次发现(u,v)时是通过u发现，此时v为白色，则(u,v)为树边。如果是通过发现，则(u,v)是一条后向边，因为此时v尚未处理完成，u自然是灰色的。




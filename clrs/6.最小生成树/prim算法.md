## Prim算法

prim算法与kruskal算法不同之处在于，kruskal算法任意构建与合并连通分支，prim算法在开始时任意选择了一个源顶点，从该点开始向外搜索和更新，不断扩充包含源点的连通分支，最终使所有顶点都进入这一连通分支。

prim算法的正确性证明蕴含在通用算法正确性证明的的推论中，同时prim算法可以视为kruskal算法的一种特殊形式。

伪代码如下

```pseudocode
MST-PRIM
for each u 属于 G.V
	u.key = inf	//初始情况下所有点均不可达
	u.predecessor = nil	//所有点都没有前驱
r.key = 0 //确定原点
Q = G.V //对图的顶点构建优先队列
while Q is not null
 u = Q.pop()	//取出连接A所在连通分支与外部的轻边（以点的形式表达）
 for each v，v与u相邻	//更新这个点与周围点的距离
 	if v in Q and w(u,v)<v.key	//如果v不在Q中，则一定与源点在同一个连通分支，因此跳过这个点。
 															//如果能让距离的上界变小，则将这个点作为周围某一点的前驱
 		v.predecessor = u
 		v.key = w(u,v)	//修改这个点的上界（优先队列中的次序也受到影响）
```

时间复杂性分析：

1. 优先队列的堆化复杂度为O( VlgV )
2. while循环执行V次，即考察每一个点
3. 对于每一个点，从优先队列中提取出来复杂度为O( lgV )
4. for循环考察每一个点的相邻点，即考察每一条边两次，共执行O( E )次
5. for循环内部if执行一次的复杂度为O( lgV )
6. for循环的复杂度为O( ElgV )
7. 所以算法复杂度为O( ElgV )

注：如果采用斐波那契堆实现优先队列，则prim算法的时间复杂度为O( E+ VlgV )